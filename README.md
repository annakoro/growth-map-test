# Архитектура хранения прогресса пользователя

## 1. Какие таблицы нужны?

### `modules` — список обучающих модулей

| Column      | Type | Description                     |
| ----------- | ---- | ------------------------------- |
| id (PK)     | int  | Уникальный идентификатор модуля |
| title       | text | Название модуля                 |
| order_index | int  | Порядок отображения модулей     |

---

### `users` — пользователи (из Supabase Auth)

| Column  | Type | Description                           |
| ------- | ---- | ------------------------------------- |
| id (PK) | uuid | Уникальный идентификатор пользователя |

---

### `user_module_progress` — прогресс пользователя

| Column       | Type    | Description                                |
| ------------ | ------- | ------------------------------------------ |
| user_id      | uuid    | Идентификатор пользователя (FK → users.id) |
| module_id    | int     | Идентификатор модуля (FK → modules.id)     |
| is_completed | boolean | Пройден ли модуль                          |
| completed_at | Time    | Дата и время завершения (nullable)         |

---

## 2. Как связать пользователя и статус урока?

- Связь реализуется через таблицу `user_module_progress`.
- Статус урока **не хранится в базе**, а вычисляется динамически:
  - **done** — модуль отмечен как завершён (`is_completed = TRUE`)
  - **active** — первый незавершённый модуль по порядку
  - **locked** — все следующие модули после active

Так база хранит только факты, а статус вычисляется на сервере.

---

## 3. Как эффективно отдавать список на фронтенд?

Эффективная схема отдачи данных:

1. Backend получает `user_id`.
2. Загружает список модулей по порядку.
3. Подтягивает прогресс пользователя.
4. На сервере вычисляет статусы:
   - завершённые - `done`
   - первый незавершённый - `active`
   - остальные - `locked`
5. Отдаёт на фронтенд **готовый массив модулей со статусами**.

Фронтенд просто отображает данные, не рассчитывая статусы самостоятельно.
